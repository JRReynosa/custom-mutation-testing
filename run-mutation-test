#! /usr/bin/env node

/*
 * Author: Ayaan Kazerouni <ayaan@vt.edu>
 * Description: Run mutation analysis on projects from a taskFile. 
 *
 * Overview:
 *  - Copy project to /tmp/
 *  - Create artificial package structure for the project so that
 *    PIT doesn't try to mutate itself
 *  - Run PIT from the ANT build file (assumed to be in the current directory)
 * 
 * NPM dependencies:
 *  - npm install fs-extra, util-promisify
 *  - or simply npm install if you have package.json or package-lock.json
 *
 * Mutation testing dependencies:
 *  - ANT (https://ant.apache.org)
 *  - PIT (http://pitest.org)
 *  - see lib/ for required jars to get PIT running
 *
 * Usage:
 *  - Part of a parallel job, using GNU Parallel (see ./run-all)
 *  - Run as a CLI tool on one or more projects.
 *    Usage: ./run-mutation-test -h
 */

'use strict';

const path = require('path');
const readline = require('readline');
const fs = require('fs-extra');
const promisify = require('util-promisify');
const exec = promisify(require('child_process').exec);
const execSync = require('child_process').execSync;
const traverseList = promisify(require('fs-tree-traverse').list);

if (process.argv.includes('-h') || process.argv.includes('--help')) {
  console.log('Run mutation analysis on projects from a taskFile.');
  console.log('Usage: ./run-mutation-test tasks.json [-l]');
  console.log('taskFile\t NDJSON file containing tasks with the keys:');
  console.log('\t\t{projectPath (required), antTask (default "pit")');
  console.log('-l\t Print stdout and stderr? Don\'t use this with GNU parallel'); 
  process.exit(0);
}

const argFile = process.argv[2];
if (!argFile) {
  console.error('Error, no args :-(');
  process.exit(1);
}

let log = false;
if (process.argv[3] || process.argv[3] === '-l') {
  log = true;
}

const NS_PER_SEC = 1e9;

function run() {
  // Entry point
  const rl = readline.createInterface({
    input: fs.createReadStream(argFile),
    crlfDelay: Infinity
  });

  rl.on('line', async (line) => {
    const opts = JSON.parse(line);
    const hrstart = process.hrtime();
    let success = true, message = '', logOutput;
    const result = await testSingleProject(opts)
      .catch((err) => {
        success = false;
        message = err.message;
        if (log) {
          logOutput = err.stdout.replace('\\n', '\n');
        }
      });

    const diff = process.hrtime(hrstart); 
    const runningTime = diff[0] + (diff[1] / NS_PER_SEC);
    const output = {
      success,
      projectPath: opts.projectPath,
      message,
      runningTime
    };
    console.log(JSON.stringify(output));

    if (log) {
      if (result) {
        logOutput = result.replace('\\n', '\n');
      }

      console.log(logOutput);
    }
  });
}

/**
 * Run mutation testing on a single project. has file system side effects.
 * Copies the project to /tmp/ and runs mutation testing using PIT. PIT
 * results are in /tmp/{projectPath}/pitReports.
 *
 * @param options An object containing the keys projectPath (required) and
 *                antTask (optional, defaults to "pit")
 *
 * @return a Promise whose result will contain the results of the ANT build ({ stdout, stderr })
 */
async function testSingleProject(options) {
  // copy the project to /tmp/ to avoid modifying the original
  const { projectPath, antTask = 'pit' } = options;
  const clonePath = path.join('/tmp/mutation-testing', path.basename(projectPath)); 
  const src = path.join(clonePath, 'src');
  const pkg = path.join(src, 'com', 'example');

  await fs.copy(projectPath, clonePath);

  // Create artificial package structure for items in the default package
  // so PIT doesn't try to mutate itself (src/com/example)
  await fs.mkdirp(pkg);

  // Move Java files directly under src into src/com/example
  await exec(`mv ${path.join(src, '*.java')} ${pkg}`);

  // Add the package declaration to the top of Java files
  await exec(`sed -i '1ipackage com.example;' ${path.join(pkg, '*.java')}`);
 
  // Prepare to run PIT using ANT
  const antPath = path.join(__dirname, 'build.xml'); // path to shared build file
  const libPath = path.join(__dirname, 'lib'); // path to shared libraries 
  const { targetClasses, targetTests } = await getPitTargets(src); 
  let cmd = `ant -f ${antPath} -Dbasedir=${clonePath} -Dresource_dir=${libPath} -Dtarget_classes=${targetClasses} -Dtarget_tests=${targetTests} ${antTask}`;
  if (!log) {
    cmd = cmd + ' > /dev/null 2>&1';
  }
  
  // execute ANT
  return execSync(cmd);
}

/**
 * Compute package to point PIT at.
 *
 * @param src Directory containing Java source files
 * @return { targetClasses, targetTests }
 */
async function getPitTargets(src) {
  const dirTree = await traverseList(src, { relative: true } );
  let targetClasses = [];
  let targetTests = [];
  let dirs = dirTree.map(p => path.dirname(p)); 
  
  dirs = [...new Set(dirs)]; // unique 
  dirs.forEach(d => {
    d = d.replace("/", ".");
    let packageName;
    if (d.endsWith(".")) {
      packageName = `${d}*`; 
    } else {
      packageName = `${d}.*`; 
    }

    targetClasses.push(packageName);
    targetTests.push(`${packageName}Test*`);
  });

  targetClasses = targetClasses.join(",");
  targetTests = targetTests.join(",");

  return { targetClasses, targetTests };
}

run();
